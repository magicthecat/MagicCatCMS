export default {"href":"/architecture/network-interactivity","html":"<h1>Molecules, Ants & Login Systems: an exploration of complex system design in the context of software development and how to make it easier. </h1>\n    <h2>Foreword</h2>\n    <p>The catalyst for writing this up was when sitting at my computer and looking at a graph. This graph showed the number of errors that had been logged in a system once a new component had gone live in a production environment. The number of errors was exponential over time. Obviously the first reaction is: this is concerning. Not only because exponential growth in errors means there’s a lot of work to be done, and quickly; but also potentially because in the last couple of years the ‘exponential growth’ chart has become ubiquitous with pretty much everyone’s lived experience. Covid-19 has had a tremendous impact on how we look at data, especially that initial ‘gut reaction’. Exponential Growth has become a heuristic by which our brains can automatically assume ‘this means something bad and out of control’. This is not a bad heuristic, as it is quite possibly always true. </p>\n    <p>Beyond my initial reaction though, it did get me thinking about ‘what are we talking about when we talk about graphs’. This is perhaps an odd observation, but when looking at that graph, you could almost hear it ‘humming’, like an overwrought engine: almost breaking under the strain of all the activity happening below the curve that was pushing it upwards and upwards.This initial mini thought experiment was the catalyst for the following. In fairness it’s a long read, so I’ve provided a summary too.</p>\n    <h2>Summary</h2>\n    <h3>The theory…</h3>\n    <ul>\n       <li>Complex systems are everywhere and we interact with them every day. Not just the internet: we are complex systems, habitats are complex systems, even driving to the supermarket to buy a loaf of bread, you’re in a complex system. </li>\n       <li>Complex systems are made up of numerous ‘nodes’. You can think of a system as a ‘network of nodes’. </li>\n       <li>‘Nodes’ can be thought of as simple ‘input → process → output’ components. Networks are when these ‘nodes’ are chained together.</li>\n       <li>When combined together, there are certain phenomena that can be seen. Emergent behaviour is one; system growth (including  exponential growth) another.</li>\n       <li>There are some complex systems that are engendered through no executive top-down design. For example, the global financial system, snowflakes, ant colonies.However, there are many examples of complex systems that humans (if they’re not designing the entirety of a complex system) are at least playing a large role in designing (the internet for example).</li>\n    </ul>\n    <h3>In practice…</h3>\n    <ul>\n       <li>We then have to find a way as humans to navigate both the overall ‘network’ and also consider how we reliably design and build ‘nodes’ within that network.</li>\n       <li>We can do this by following some guiding principles in how to approach complex systems and how we can approach individual node design.</li>\n       <li>\n          At a system level, we can approach design with these 9 principles:\n          <ul>\n             <li>Define the system's boundaries\t</li>\n             <li>Identify system nodes\t</li>\n             <li>Analyse system dynamics\t</li>\n             <li>Identify critical points\t</li>\n             <li>Consider multiple perspectives\t</li>\n             <li>Design for resilience\t</li>\n             <li>Test &amp; Iterate\t</li>\n             <li>Incorporate flexibility\t</li>\n             <li>Identify system level rules</li>\n          </ul>\n       </li>\n       <li>\n          At an individual ‘node’ level we approach design with these 8 principles:\n          <ul>\n             <li>Understand the role of a node\t</li>\n             <li>Consider the Human Nodes\t</li>\n             <li>Optimise node design\t</li>\n             <li>Incorporate redundancy\t</li>\n             <li>Design for variability\t</li>\n             <li>Implement monitoring and feedback\t</li>\n             <li>Ensure security and privacy\t</li>\n             <li>Consider environmental factors</li>\n          </ul>\n       </li>\n       <li>\n          When we go into the ‘real world’ of actually doing requirements analysis for a single node, we can ‘checklist’ using these 8 items:\n          <ul>\n             <li>Identify the purpose and function of the node.</li>\n             <li>Determine the criticality of the node and its role in the system.</li>\n             <li>Evaluate the environmental factors that may impact node performance.</li>\n             <li>Consider the potential risks and hazards associated with the node.</li>\n             <li>Determine the necessary redundancy and backup measures for the node.</li>\n             <li>Design for variability and flexibility in node interactions.</li>\n             <li>Implement monitoring and feedback mechanisms for the node.</li>\n             <li>Ensure security and privacy measures are in place for the node.</li>\n          </ul>\n       </li>\n    </ul>\n    <h3>Conclusion</h3>\n    <ul>\n       <li>The conclusion of the article is that these approaches can help mitigate issues at the system level by ensuring good individual ‘node’ design. However, understanding the theoretical underpinnings of complex systems, emergence and ‘node interactivity’ is also just as important as being able to ‘checklist requirements’. This is because, as system designers, we’re as much a part of the system we’re designing as the individual components of the system itself.</li>\n    </ul>\n    <h2>Introduction</h2>\n    <p>In today's interconnected world, complex systems are ubiquitous and increasingly important. These systems consist of many interdependent nodes that interact with each other in intricate ways, often leading to emergent behaviour that is difficult to predict or control. The article takes the view that in many cases, traditional top-down design approaches are insufficient to deal with this complexity, and new methods and tools are needed to ensure the resilience, adaptability, and reliability of complex systems. This article hopes to contribute somewhat to, if not by creating these tools, at least by providing a theoretical starting point by exploring how node interactivity within a network can be a useful paradigm for designing for complex systems. Within this paradigm, it discusses various approaches to system design, including defining system boundaries, identifying components, analysing dynamics, identifying critical points, considering multiple perspectives, designing for resilience, testing and iterating, and incorporating flexibility. The article also emphasises the importance of understanding human nodes in the system and considering their needs, motivations, and limitations.  Finally, it highlights the relevance of the article to various fields and domains and identifies some potential challenges and future directions for research and development in this area.</p>\n    <p>This article is split into two distinct sections. First we'll look at the theoretical underpinnings of complex systems (sections 1-4); and then we’ll discuss its practical implications within the context of software engineering (sections 5 and onwards). If you are purely interested in the practical implications, feel free to skip. </p>\n    <h2>Node Interactivity</h2>\n    <p>Node interactivity in a network refers to the connections and interactions between the individual components, or nodes, that make up the network. A node can be any unit of the network, including individuals, institutions, ideas, or even atoms or molecules, depending on the system being considered. The interactions between these nodes enable feedback loops and self-reinforcing processes that can drive exponential growth in the system (Barabási, 2002; Boccaletti et al., 2006).</p>\n    <p>For example, in a social network, the nodes would be the individuals, and the interactions would include the connections or friendships between those individuals. These connections can lead to feedback loops, where a person's friends may introduce them to new people, leading to more connections and ultimately more growth in the network.</p>\n    <p>Similarly, in the case of a technological network, nodes could represent individual researchers or institutions, and the interactions between them would include the sharing of ideas and resources. This exchange can lead to the creation of new technologies, which can then be built upon and further developed, leading to exponential growth in the network.</p>\n    <p>Overall, the concept of node interactivity in a network allows us to build an  understanding of how networks operate. By considering the nodes and interactions within a network, we can gain insights into the mechanisms that drive growth and development, allowing us to better understand and predict the behaviour of complex systems (Seabrook, Barucca and Caccioli, 2022; (Liu et al., 2021)</p>\n    <h2>Practical Implications of ‘Node Interactivity’</h2>\n    <p>Understanding node interactivity in a network is essential for understanding complex systems and optimising their performance. It has practical applications in many fields, including marketing, transportation, epidemiology, supply chain management, and technology development.</p>\n    <p>One of the most significant applications of understanding node interactivity is in marketing and advertising. By understanding the interactions between individuals in a social network, marketers can identify key influencers who have the most significant impact on the network's behaviour. These influencers can then be targeted to promote products or services, leading to more effective marketing campaigns.</p>\n    <p>In transportation, node interactivity is crucial for designing efficient transportation systems that minimise congestion and improve overall system performance. Transportation networks are complex systems that involve interactions between nodes such as vehicles, roads, and passengers. Understanding the interactions between these nodes can help transportation planners optimise the flow of traffic and reduce travel times.</p>\n    <p>In epidemiology, the spread of infectious diseases is often modelled as a network of interactions between individuals. By understanding the interactions between nodes in the network, epidemiologists can identify potential sources of outbreaks and design strategies to control their spread.</p>\n    <p>Supply chain networks involve interactions between multiple nodes, such as suppliers, manufacturers, and retailers. Understanding the interactions between these nodes can help supply chain managers optimise the flow of goods and reduce costs.</p>\n    <p>Equally, technological networks involve interactions between nodes such as researchers, inventors, and investors. Understanding these interactions can help researchers identify potential collaborators and investors who can help them develop and commercialise their ideas.</p>\n    <p>These are just a few examples of the practical applications of understanding node interactivity in a network. The concept is relevant to many different fields and systems, and the potential benefits of this understanding are numerous. By analysing the interactions between nodes, researchers and practitioners can gain insights into the behaviour of complex systems, develop more effective strategies for controlling or optimising their performance, and drive innovation in a variety of fields. As such, understanding node interactivity is a critical aspect of modern problem-solving and has become increasingly important in the face of the world's growing complexity.</p>\n    <h2>Node Interactivity &amp; Exponential Growth</h2>\n    <p>The interactions between nodes in a network enable self-reinforcing processes that allow for the growth and development of the network. As more nodes are added, the number of connections and interactions between them increases, leading to further growth and development.This feedback loop can lead to exponential growth, as the network becomes larger and more complex (Hevey, 2018; Herranz, 2009). Exponential growth is a ubiquitous phenomenon in nature and human-made systems, from the spread of diseases to the growth of populations to the advancement of technology and therefore it is possible to argue that all exponential growth is driven by interactivity in a network, even if that's self-reinforcing processes.</p>\n    <p>Firstly, let's consider the self-reinforcing process of population growth. As a population grows, there are more individuals who can reproduce, leading to an increase in the birth rate. This, in turn, leads to an even larger population, which can produce more offspring, creating a feedback loop of growth (Manson, 2001). Equally, population decline can be a self-reinforcing process (Haartsen and Venhorst, 2014). While this process appears to be self-sustaining, it is ultimately driven by interactions between individuals in a network. The interactions between individuals, including mating and reproduction, are what enable the growth to occur in the first place.</p>\n    <p>Similarly, technological progress can exhibit exponential growth due to the self-reinforcing nature of innovation. As new technologies are developed, they enable the creation of even more advanced technologies, creating a feedback loop of innovation. However, this process is also driven by interactions between individuals and institutions in a network. Ideas are shared and built upon, investments are made, and research is conducted based on the feedback and influence of others in the network (Ivanova et al. 2020).</p>\n    <p>In fact, even in cellular systems where interactions may at first appear to be contained within the cell, interactivity in a network can be observed. We can now determine how and when various molecules interact with each other within a cell, giving rise to molecular interaction networks such as protein-protein interaction, metabolic, signalling, and transcription-regulatory networks. These interactions collectively determine the system-scale behaviour of the cell, even when molecular interactions are themselves feedback loops (Alon, 2006). Interestingly, the architectural features of molecular interaction networks within a cell are shared to a large degree by other complex systems, such as the Internet, computer chips, or society (Barabási and Oltvai, 2004).</p>\n    <p>Therefore, it's possible to consider that although not all growth is exponential, all exponential growth is ultimately driven by interactivity in a network, even if that's self-reinforcing processes. The specific mechanisms of this interactivity may differ depending on the system under consideration, but ultimately, it is the interactions between the components of the system that enable exponential growth to occur.</p>\n    <h2>Emergence &amp; Chaos</h2>\n    <p>The previous section has highlighted the significant role of node interactivity in driving exponential growth in various systems. However, it's not just the presence of interactivity that drives this growth, but also the specific mechanisms of this interactivity. While it's possible to argue that all exponential growth is ultimately driven by interactivity in a network, this does not necessarily imply that it is an uncontrollable or chaotic process. In reality, interactivity often follows specific rules and patterns that lead to emergent properties in the network (Barabási and Oltvai, 2004). Understanding these patterns and rules is critical for harnessing the potential of node interactivity in driving growth and development in various fields.</p>\n    <p>This section will provide an introduction to the concept of emergence in complex systems. Emergence refers to the observation that in complex systems, the behaviour of the system as a whole often cannot be predicted from the behaviour of its individual components.Instead, the system exhibits emergent properties that arise from the interactions between the components of the system (Fisher et al.,, 2020). These emergent properties are not present in the individual components but only emerge at the system level. Understanding emergence is crucial for understanding how node interactivity can lead to growth and development in a network, as well as for predicting and controlling the behaviour of complex systems (Zheng, 2020)</p>\n    <h3>Node Interactivity &amp; Emergent Behaviour</h3>\n    <p>Emergent behaviour is a phenomenon that can arise from node interactivity in complex systems. Self-organising behaviour is one type of emergent behaviour that can arise from the interactions between nodes in a network. Self-organisation refers to the spontaneous formation of order from disorder in a system, without any external influence or control (Steinhardt, 2021)</p>\n    <p>In a network, self-organising behaviour can arise from simple local interactions between nodes, without the need for a central coordinator or controller. Each node in the network responds to the information it receives from its neighbouring nodes and adjusts its behaviour accordingly, leading to a collective pattern of behaviour that emerges at the network level.</p>\n    <p>One example of self-organising behaviour is flocking in birds. Each bird responds to the movements of its nearest neighbours, leading to a coordinated pattern of movement at the flock level. Another example is the behaviour of ants in a colony, where each ant follows simple rules based on the pheromone trails laid by other ants, leading to the emergence of complex colony-wide behaviour (Macktoobian, 2022).</p>\n    <p>Self-organising behaviour can also be observed in technological systems, such as the internet. The internet is a decentralised network of nodes, with no central control or coordination. However, through the interactions between nodes, information can be routed and transmitted efficiently, leading to the emergence of a robust and reliable communication network (Barabási and Oltvai, 2004).</p>\n    <p>Therefore, we can consider that self-organising behaviour can emerge from node interactivity but this leads to the question on what are the consequences of self-organising behaviour emerging. The next section will explore some of the benefits and drawbacks of emergent behaviour. </p>\n    <h3>Drawbacks and Benefits of Emergent Behaviour</h3>\n    <p>As we have seen, the specific mechanisms of interactivity can lead to the emergence of patterns and rules that govern the behaviour of the system as a whole, rather than just its individual components. These emergent properties can be beneficial, driving growth and development in various fields, but they can also have drawbacks that must be carefully considered (Bommasani et al., 2021).</p>\n    <p>One of the most intriguing aspects of emergent behaviour is that it often arises spontaneously, without any explicit instruction or direction from a central authority (Macktoobian, 2022). This is known as self-organising behaviour, and it can be seen in many natural and artificial systems. For example, ant colonies exhibit self-organising behaviour in the way that they forage for food and allocate tasks among individual ants. Each ant follows a set of simple rules that dictate its behaviour, such as following a pheromone trail laid down by other ants, and as a result, the colony as a whole is able to find food and survive (Song et al., 2020).</p>\n    <p>Another example of self-organising behaviour can be seen in traffic flow. In a network of roads, there is no central authority directing the movement of individual cars, yet traffic flows in a coordinated way that allows for efficient movement. This is due to the emergent behaviour that arises from the interactions between cars, such as the tendency to maintain a safe distance from the car in front, and the ability to merge into traffic smoothly (Assaad et al. 2020)</p>\n    <p>However, while emergent behaviour can have benefits, it can also have drawbacks. For example, in financial systems, the emergence of self-organising behaviour can lead to the formation of bubbles and crashes. This is because investors follow the same rules and patterns of behaviour, such as buying when prices are rising and selling when they are falling, which can create feedback loops that amplify market fluctuations. This can result in unstable and unpredictable behaviour that can be harmful to the overall system (Capelli, 2022).</p>\n    <p>Another drawback of emergent behaviour is that it can be difficult to control or predict. This is because the rules and patterns that govern the behaviour of the system as a whole can be complex and difficult to understand. For example, in ecosystems, the emergence of self-organising behaviour can lead to the extinction of certain species or the dominance of others, which can have far-reaching consequences for the health of the ecosystem as a whole (Frølich et al., 2022).</p>\n    <p>As we can see, emergent behaviour that can arise from node interactivity, while it can have benefits, such as driving growth and development, it can also have drawbacks that must be carefully considered. By understanding the mechanisms of interactivity and the rules that govern emergent behaviour, we can harness the potential of node interactivity to drive growth and development in various fields, while minimising its drawbacks. The next section will look at how we can harness emergent behaviour in the context of complex system design.</p>\n    <h2>Approaches to Complex System Design</h2>\n    <p>Understanding the mechanisms by which complex systems generate emergent behaviour is essential for predicting their behaviour and designing interventions that can effectively control or enhance their performance. The previous sections have explored some of the mechanisms of how emergent behaviour can arise. This section will explore how this knowledge can be applied to the design of complex systems. It's important to note that emergent behaviour is not always desirable. In some cases, emergent behaviour can lead to system failures or unpredictable outcomes. For example, in the field of artificial intelligence, emergent behaviour in autonomous systems can lead to unintended consequences or even dangerous behaviour (Bommasani et al., 2021). Therefore, it is crucial to design complex systems with safeguards in place to prevent emergent behaviour from leading to negative outcomes, whilst also capitalising on any potential gains from emergent behaviour.</p>\n    <p>Here are nine approaches to consider when designing for complex systems:</p>\n    <h3>Define the system's boundaries</h3>\n    <p>Defining a complex system's boundaries is crucial to understanding its behaviour and interactions with the environment (Inclan, 2021). In the context of software delivery, a system can be a software application, a group of applications, or an entire IT infrastructure. Defining the system's boundaries involves identifying the inputs and outputs of the system, the nodes that make up the system, and the interactions between these nodes and the external environment.</p>\n    <p>For example, consider a software delivery pipeline. The system's inputs are the software code, configuration files, and other artefacts that are developed by the software development team. The outputs are the compiled code, packaged software, and documentation that are delivered to the end-users. The nodes in this network (i.e. ‘system’) include the source code repository, the build server, the testing infrastructure, the deployment tools, and the monitoring system. The interactions between these nodes also include interactions with the software development team, the IT operations team, and the end-users, which in themselves are ‘nodes’.</p>\n    <p>In order to define the system’s boundaries, we need to consider all the nodes mentioned above. When doing so, however, it is important to be judicious about where the network or system actually ends as this boundary can be fuzzy; there will always be some compromise on where boundaries are drawn (Betley et al., 2021).</p>\n    <p>In our example, having defined the boundaries of the software delivery pipeline we are then in a better position to identify potential bottlenecks, failure points, and areas of improvement. For instance, the system's performance can be improved by optimising the interactions between the components, such as reducing the build time or improving the deployment process. Similarly, by understanding the system's boundaries, it becomes easier to identify the external factors that can affect the system's behaviour, such as changes in the software development process or upgrades to the underlying infrastructure.</p>\n    <h3>Identify system nodes</h3>\n    <p>Identifying the individual nodes that make up the system is a challenging yet important task. In complex systems, these components can range from simple elements to highly interconnected subsystems. The purpose of identifying system components is to gain a better understanding of how they work together to achieve the system's goals.</p>\n    <p>A good starting point is to create a comprehensive inventory of all system nodes, including both physical and abstract nodes. Whilst this is not always practical to do in one go; an iterative approach can be taken. This involves considering already identified nodes and identifying what their immediate nodes are and repeating the process until the edge of the system is reached. Identified physical ‘nodes’ refer to tangible parts of the system, such as software, hardware or equipment, while abstract components refer to intangible elements such as business processes.</p>\n    <p>It's also important to understand how each node interacts with other nodes. This involves identifying the relationships and dependencies between nodes. In some cases, these relationships may be direct, while in others they may be indirect or mediated by other components.</p>\n    <p>To help identify system components and their relationships, a variety of tools and techniques can be used, such as system diagrams, flowcharts, and data flow diagrams. These visual representations can help to clarify complex relationships and dependencies, and identify potential points of failure or bottlenecks in the system.</p>\n    <p>As an example, consider a software delivery system. The system's nodes may include code repositories, build servers, testing frameworks, and deployment pipelines. Each component interacts with others to ensure that the software is built, tested, and deployed to production environments. By identifying these nodes and their relationships, it's possible to then identify how these ‘nodes’ may contain nodes themselves. The level of abstraction to which we go will depend on the context in which we are conducting analysis. For example, when looking at optimising source code, nodes could be individual functions; when looking to improve an overall software release process, nodes may be a build process. Whatever level of abstraction is decided on however, the overall aim of identifying individual system nodes is to provide us with a better chance  to optimise the software delivery process, reduce bottlenecks, and improve overall system performance.</p>\n    <p>It's important to note however that, when designing complex systems, humans are also critical ‘nodes’ in the system and therefore shouldn’t be ignored: the individuals who interact with these components play a crucial role in determining the success of the system. Considering their needs, limitations, and motivations in the design process, is critical to the overall system design (Neumann et al., 2021)</p>\n    <p>For example, in the context of designing a new software delivery system, it's crucial to consider the needs and limitations of the developers who will be using the system. The design should take into account the tools and resources that they need to do their jobs effectively. It should also consider their workflows and processes to ensure that the system integrates seamlessly into their existing work practices. Additionally, it's important to consider the end-users who will interact with the software and ensure that their needs and expectations are met.</p>\n    <p>Ignoring humans in the system can lead to significant problems. For instance, a poorly designed software delivery system that doesn't take into account the needs of the developers can result in low productivity, increased errors, and burnout (Venkatesh et al., 2020). Similarly, a software system that doesn't consider the needs of end-users can result in poor user experience, low adoption rates, and negative feedback (Almazroi, 2023)</p>\n    <h3>Analyse system dynamics</h3>\n    <p>Analysing system dynamics is crucial for designing effective complex systems in software engineering. Here are some ways to do so:</p>\n    <ul>\n       <li>Analyse feedback loops: Feedback loops are essential in software engineering as they help teams to monitor the performance of their systems and adjust accordingly (Kortum et al. 2017).  For instance, in continuous integration and continuous delivery (CI/CD), a feedback loop can be created to track the progress of a build and notify the team of any errors or issues that need to be addressed.</li>\n       <li>Consider delays: Delays can significantly impact system performance, especially in software engineering. For instance, a delay in the processing of a request can lead to a backlog of requests, causing system downtime. Therefore, it's crucial to identify potential sources of delays and address them proactively to prevent system failure.</li>\n       <li>Analyse non-linear relationships: Software systems often have non-linear relationships between their components (Delgado-Maciel et al., 2020). For instance, the performance of a database system may not be linearly related to the amount of data stored in it. Therefore, it's important to understand these relationships to design effective systems. One approach is to use simulations to analyse non-linear relationships and identify potential bottlenecks or performance issues.</li>\n       <li>Understand emergent behaviour: Emergent behaviour can also arise in software systems due to the interaction of multiple components (Wingo, 2015). For example, a performance issue in one component may lead to a cascade of failures in other components, ultimately resulting in system failure. Therefore, it's important to design systems with emergent behaviour in mind and build redundancy and fail-safes into the system to prevent catastrophic failures.</li>\n    </ul>\n    <p>It’s important to note that analysing system dynamics in software engineering is an ongoing process that requires continuous monitoring and adjustments, rather than it purely being something that happens during the design phase of a system. By understanding the complex interactions between system components, teams can design effective systems that are resilient and reliable.</p>\n    <h3>Identify critical points</h3>\n    <p>Identifying critical points in a complex system is crucial for designing effective interventions and controlling the system's behaviour. Here are some steps to follow when identifying critical points:</p>\n    <p>Firstly, map out the system's known nodes and interactions, as this will help to identify where bottlenecks or failure points may occur. In the context of software engineering, this may include examining the codebase and infrastructure to identify potential bottlenecks or failure points.</p>\n    <p>Secondly, consider the impact of small changes on the system's behaviour. In some cases, small changes may have a negligible impact on the system, while in others, they can trigger significant changes in the system's behaviour. For example, in software engineering, changing a single line of code may have little effect on the overall system, but changing a critical configuration parameter could cause a failure or bottleneck.</p>\n    <p>Thirdly, examine the system's behaviour under stress or unexpected conditions. This can help to identify tipping points, where the system's behaviour changes rapidly in response to small changes. For example, in software engineering, load testing can help to identify the point at which the system becomes overloaded and performance degrades rapidly.</p>\n    <p>Finally, consider the potential consequences of failure or disruption at critical points in the system. This can help to prioritise interventions and focus efforts on the most critical areas of the system. For example, in software engineering, a failure at a critical point in the system could result in data loss, security breaches, or system downtime, so it's important to identify and address these critical points as early as possible.</p>\n    <h3>Consider multiple perspectives</h3>\n    <p>Designing a complex system involves more than just understanding the technical components and dynamics. It's essential to consider the perspectives of all stakeholders involved in the system, both internal and external, to ensure that the design meets all relevant requirements (Neumann et al., 2021)</p>\n    <p>Internal stakeholders:</p>\n    <ol>\n       <li>Internal stakeholders refer to individuals or groups within the organisation who are directly involved in the design, development, and implementation of the system. It includes developers, engineers, project managers, and other team members. Their perspective is crucial in understanding the technical requirements and constraints of the system, ensuring that the system is feasible and achievable.</li>\n    </ol>\n    <p>External stakeholders:</p>\n    <ol>\n       <li>External stakeholders refer to individuals or groups outside the organisation who have an interest in the system's success. It includes customers, end-users, regulatory bodies, and other third-party organisations. Their perspective is essential in understanding the user requirements, identifying potential risks and challenges, and ensuring that the system is compliant with relevant laws and regulations.</li>\n    </ol>\n    <p>Considering multiple perspectives helps to identify potential conflicts, trade-offs, and dependencies that can impact the system's design and performance. It can also help to identify opportunities for collaboration, innovation, and value creation.</p>\n    <p>For example, when designing a software application, multiple perspectives may include:</p>\n    <ul>\n       <li>Developers: They need to consider the technical feasibility of the design, including the programming languages, frameworks, and tools used to build the application.</li>\n       <li>End-users: They need to consider the user experience and interface design, ensuring that the application is intuitive, user-friendly, and meets their needs.</li>\n       <li>Regulatory bodies: They need to consider data security and privacy requirements, ensuring that the application is compliant with relevant laws and regulations.</li>\n       <li>Business stakeholders: They need to consider the business goals and objectives, ensuring that the application aligns with the organisation's overall strategy and vision.</li>\n    </ul>\n    <p>Considering these multiple perspectives can help to ensure that the software application is not only technically feasible but also meets the needs and expectations of all stakeholders involved. Equally, after the software delivery, the system will operate within a larger system, which includes other organisations, individuals, and environmental factors. In this context, it is crucial to consider multiple perspectives to ensure the system's design meets all relevant requirements and that it functions effectively in the larger system. In addition, considering multiple perspectives can help predict potential interactions between nodes in the larger system and identify opportunities for improvement or adaptation. By recognizing the interconnectedness of systems and the importance of multiple perspectives, the design of complex systems can be improved and optimised to achieve the best possible outcomes for all stakeholders involved.</p>\n    <h3>Design for resilience</h3>\n    <p>Resilience is the ability of a system to maintain its function and structure in the face of disturbances or changes. In complex systems, disruptions are inevitable, whether they are caused by internal faults or external events. Therefore, designing for resilience is critical to ensure the system can continue to function and achieve its goals in the face of challenging conditions (Brtis and McEvilley, 2019).  Here are some key considerations for designing for resilience:</p>\n    <ol>\n       <li>Identify potential disruptions: Start by identifying potential disruptions, including internal faults, external events, and unexpected circumstances. This can involve conducting risk assessments, scenario planning, or reviewing historical data to identify potential issues.</li>\n       <li>Plan for resilience: Once potential disruptions have been identified, plan for resilience by designing the system to withstand or adapt to these disruptions. This could involve building redundancy into the system, developing contingency plans, or implementing fail-safes to prevent catastrophic failures.</li>\n       <li>Test for resilience: Test the system's resilience through simulations or real-world testing to identify any weaknesses or vulnerabilities. This can help refine the system design and identify potential improvements.</li>\n       <li>Monitor and adapt: Monitor the system's performance and adapt as necessary to ensure continued resilience. This could involve implementing ongoing maintenance, regular testing and evaluation, or incorporating new technologies or processes to improve resilience over time.</li>\n    </ol>\n    <p>Designing for resilience is particularly important in systems that have high stakes or critical functions, such as healthcare systems, financial markets, or transportation systems. By anticipating potential disruptions and planning for resilience, designers can help ensure that these systems can continue to function even in the face of unexpected challenges.</p>\n    <h3>Test &amp; Iterate</h3>\n    <p>It's critical to test and iterate the system design to ensure its effectiveness. Testing and iterating allow designers to refine the system's components, interactions, and dynamics to achieve the desired goals. Testing can be done through simulations, prototypes, or other means to evaluate the system's behaviour under different conditions. Prototyping involves building a scaled-down version of the system to test its functionality and gather feedback from users. Simulations allow designers to model the system's behaviour in a controlled environment and evaluate its performance in different scenarios.</p>\n    <p>Iterating the system design involves taking the feedback received from testing and making adjustments to the system's components, interactions, and dynamics. This process allows designers to refine and improve the system's design to achieve the desired results. It's essential to evaluate the system's effectiveness regularly to ensure it remains relevant and useful in a changing environment. Iteration can be a cyclical process, with each iteration building on the previous one to refine the system's design continuously.</p>\n    <p>Within a software engineering context, one way to achieve this is through unit and component tests. Unit tests are used to test individual code units, such as functions or methods, to ensure that they are working correctly. Component tests, on the other hand, test larger sections of code, such as modules or classes, to ensure that they are functioning as intended.</p>\n    <p>Implementing unit and component tests involves writing test cases that explicitly cover the possible inputs and outputs of the piece of code in question. These tests should be automated, so they can be run regularly throughout the development process. By running these tests regularly, developers can catch any errors or bugs early on and fix them before they become more significant issues. Additionally, as the codebase grows and changes, developers can continue to add new tests to ensure that the system remains stable and robust over time.</p>\n    <h3>Incorporate flexibility</h3>\n    <p>Due to the very nature of how social and technical networks operate, the requirements of a system and its constituent parts can change rapidly; a flexible design can enable the system to adapt to changing conditions without significant disruption or delay. For example, incorporating modularity into the system design can allow for individual ‘nodes’ to be modified or replaced without affecting the overall system's functionality. Additionally, the use of standardised interfaces can enable different components to be easily integrated, promoting flexibility and ease of modification.</p>\n    <p>Incorporating flexibility also requires careful consideration of the trade-offs between flexibility and other design goals such as performance, reliability, and security. For example, a highly flexible system may be more vulnerable to security threats or have reduced performance compared to a more rigidly designed system. Therefore, it is essential to strike a balance between flexibility and other design goals to ensure the system meets all relevant requirements.</p>\n    <h3>Identify system level rules</h3>\n    <p>Identifying system-level rules is probably the most important of the approaches in this section. This is because it is unlikely that a single individual or a team will be able to identify all nodes in a network from the outset of system design. Therefore, identifying system level rules is essential as it helps ensure that different nodes in a system can follow a common set of rules when processing information (Zaheri, 2022). By doing so, it reduces the risk of undesirable emergent behaviour. For instance, in a traffic system, vehicles travelling on different roads are expected to follow the same traffic laws, such as driving on the right side of the road and stopping at red lights. Similarly, when designing a secure software system, the rules that govern the login system ‘node’ (for example, password complexity requirements, timeout thresholds etc.) are rules that could be applied to other ‘nodes’ in the network. Another example of a system-level rule is User Interface (UI) standards. UI standards ensure that users can navigate through different applications and web pages consistently, which helps improve the user experience and reduce user frustration. For instance, a common UI standard is to have a search bar located in the top right corner of a web page, which enables users to locate it quickly and easily. Overall, identifying system-level rules is crucial for designing complex systems that operate smoothly and efficiently.</p>\n    <h3>Summing Up</h3>\n    <p>Above are nine different considerations that should aid in complex system design thinking. Many reading these will be familiar, in some form, with at least a few of them. However, the risk is that these considerations are often thought about at the macro-level (or in the language of this article, at the ‘network level’). There is nothing wrong with having an ‘architectural’ high level view of a complex system. However, there is a big risk in paying too much attention at the network level and paying too little attention to the micro-level. It is often quite common that on large programs of work, everything will be going fine across all projects and it will be ‘one thing’ that will scupper an overall delivery of a piece of software. More often than not, it is because the focus has been at the ‘network’ level, leaving one of the ‘nodes’ to go awry. Therefore, good design of ‘nodes’ is critical to the success of a complex system.   In the next section, we’ll explore best practice for ‘node’ design, as this is where the core focus should be.</p>\n    <h2>Approaches to ‘node’ design: keeping things ‘KISS’</h2>\n    <p>In complex systems, the focus on the network level is important, but equally important is the design of individual nodes. Good design of nodes can have a significant impact on the success of a complex system. In this section, we will explore best practices for designing nodes in complex systems. These practices will be applicable across a variety of industries, but we will use software engineering as a primary example. We will discuss the importance of understanding node interactions, designing for resilience, incorporating flexibility, and ensuring proper communication between nodes. By the end of this section, you will have a better understanding of how to design effective nodes in complex systems.</p>\n    <h3>Understand the role of a ‘node’</h3>\n    <p>To design a complex system, it is important to understand the role of a node. A node can be thought of as a singular component within the wider system that has a defined set of inputs, a process governed by a rule or set of rules, and a set of outputs. The inputs to a node are the information, data, or material it receives, the process is the activity or function it performs, and the outputs are the result of the process. </p>\n    <p>However, before we can start designing a single node, we have to know what a node actually is. Let's consider a common software engineering example of a login feature for a web application.</p>\n    <ul>\n       <li>Input: User enters their login credentials (username and password)</li>\n       <li>Process: The system validates the entered credentials against the stored credentials in the database.</li>\n       <li>Output: If the entered credentials are correct, the system allows the user to access the application. If the credentials are incorrect, the system denies access and prompts the user to enter valid credentials.</li>\n    </ul>\n    <p>One could look at this example and immediately consider it to be a single ‘node’. The \"input\" is the login form that accepts user input, the \"process\" is the validation logic that compares the entered credentials against the stored credentials, and the \"output\" is the decision to grant or deny access to the application. </p>\n    <p>Although this is perfectly correct; it is possible to look at the system at a different level of abstraction and in fact consider it to be a system (i.e. a ‘network of nodes’) containing multiple nodes. In this case three:</p>\n    <ol>\n       <li>\n          Node 1: User logs in\n          <ul>\n             <li>Input: User enters login credentials into UI and clicks \"log in\"</li>\n             <li>Process: Front-end functions encrypt user information</li>\n             <li>Output: Front-end posts user data to an authentication service</li>\n          </ul>\n       </li>\n       <li>\n          Node 2: Authentication service\n          <ul>\n             <li>Input: Receives user data from front-end</li>\n             <li>Process: Verifies user credentials against user database</li>\n             <li>Output: Sends authentication success or failure message to front-end</li>\n          </ul>\n       </li>\n       <li>\n          Node 3: Front-end\n          <ul>\n             <li>Input: Authentication success or failure message from authentication service</li>\n             <li>Process: Displays appropriate message to user</li>\n             <li>Output: N/A</li>\n          </ul>\n       </li>\n    </ol>\n    <p>So why might it be important to identify these multiple nodes and not just consider the overall operation as a single node?</p>\n    <p>When designing complex software systems, it can be tempting to view the overall operation as a single node, rather than breaking it down into its individual components. However, this can lead to significant risks and problems during software delivery. Smaller nodes can lead to numerous benefits for software engineers. Firstly, it means that more developers can work on individual components, increasing development velocity. Secondly, smaller nodes mean better ability to write automated tests that are reliable and repeatable, which can help catch bugs early in the development process. Thirdly, smaller nodes offer greater reusability, flexibility, and extensibility, as they are easier to modify and repurpose for different use cases. Fourthly, smaller nodes mean separation of concerns, which reduces the cognitive load for humans, making it easier for them to understand and maintain the system. Finally, smaller nodes can help avoid potential bottlenecks or failure points by allowing engineers to identify and address issues at a granular level. For example, in the 'log in' system, breaking it down into smaller nodes would allow for easier extension of the authentication service's functionality without tightly coupling it to the front-end, reducing potential risks of slips or mistakes.</p>\n    <p>However, the most important reason for breaking down systems into small nodes is it can make it easier for humans to understand as well as  identify and resolve issues quickly (Pinto et al, 2021).This leads us on to our next consideration.</p>\n    <h3>Consider the Human Nodes</h3>\n    <p>When designing a software system, it is crucial to consider the human nodes that will interact with it. This includes end-users who will use the software to perform tasks, developers who will design and maintain the system, and other stakeholders who may have a vested interest in the system's success. Understanding the needs, behaviours, and limitations of these human nodes is essential to designing a system that is both functional and user-friendly. For example, end-users may require a simple and intuitive user interface to perform their tasks efficiently, while developers may need a system that is modular and easy to maintain. In addition, other stakeholders may have specific requirements for the system, such as data security, scalability, or compliance with regulations. By considering the human nodes in the system and designing for their needs and behaviours, software engineers can create a system that is not only technically sound but also meets the needs of the people who will use and maintain it.</p>\n    <p>Let's consider the ‘human nodes’ in our 'login' system example. End-users are the primary stakeholders in this system, and it's essential to design for their needs and behaviours. For example, we may want to ensure that the login process is as simple and intuitive as possible, reducing cognitive load and frustration for the user. This may involve user testing and feedback to refine the login process, ensuring that it's easy for users to enter their credentials and log in quickly. It is at this point too that we may find out that other ‘nodes’ interact with our ‘front-end’. For example, there may be an entire part of the network that revolves around ‘typography’ and other design elements (such as the ‘look and feel’ of buttons). Therefore, our front-end system may receive ‘inputs’ from additional nodes as part of its ‘processing’. </p>\n    <p>On the developer side, we may want to design the system to be modular and flexible, allowing for changes and updates to individual nodes without requiring a complete overhaul of the system. This may involve establishing clear communication and documentation protocols for developers working on different nodes and implementing automated testing and deployment processes to reduce the risk of human error.</p>\n    <p>Other stakeholders, such as system administrators or security personnel, may have specific requirements or concerns around the system's performance and security. Designing for their needs may involve implementing specific security protocols, establishing clear performance metrics and monitoring tools, and ensuring that the system can be easily audited and reviewed as needed.</p>\n    <p>However, it is important to note that humans often have a transitory interaction with a system, which means that their needs and behaviours may vary. Therefore, it is important to consider a hierarchy of needs when designing for human nodes. In the case of the login system ‘authentication service’ node, both end-users and active maintainers are probably the most critical human nodes that interact with it. The business owner for example may not have much interest in the Authentication service unless it is causing issues with the overall network, and thereby putting them at operational, financial and/or regulatory risk. </p>\n    <h3>Optimise node design</h3>\n    <p>By reducing complexity and improving modularity, nodes become more maintainable and scalable, leading to a more efficient and resilient system. One way to optimise node design is to ensure that each node has a clear responsibility or function, reducing overlap and minimising confusion. Furthermore, by reducing the number of dependencies between nodes, engineers can create more modular and flexible systems, allowing for greater scalability and adaptability to changing requirements. Another way to optimise node design is to ensure scalability by designing nodes to handle expected increases in traffic and data volume. Equally,, maintainability is a critical factor in node design; engineers must ensure that nodes are easy to debug, update, and maintain to minimise downtime and reduce the risk of system failure.</p>\n    <p>Finally, and potentially slightly controversially, it's important to ensure that each node has a single, well-defined purpose. The reason for this is that if a node has multiple functions (i.e the ‘process’ incorporates multiple features), it can increase the risk of undesirable emergent behaviour, which can be difficult to predict and mitigate. Emergent behaviour occurs when the interaction between multiple components in a system creates new and unexpected behaviour that was not designed or anticipated. By limiting each node to a single function, it's easier to understand and predict its behaviour when incorporated into the wider system. This makes it easier to maintain and troubleshoot the system as a whole. Ultimately, by optimising node design and reducing complexity, developers can create more reliable, scalable, and maintainable software systems.</p>\n    <h3>Incorporate redundancy</h3>\n    <p>In engineering, redundancy refers to the duplication or triplication of critical components or systems within a larger system. The idea is that if one component or system fails, there are backup systems or components that can take over and ensure the continuity of service or function. This concept is often used in aviation, where redundant systems are used to ensure the safety of passengers and crew in the event of an equipment failure. For example, modern aircraft have redundant hydraulic and electrical systems to ensure that critical flight controls and instruments remain operational even if one system fails. Therefore, when designing complex systems, incorporating redundancy is an important consideration to ensure continuity of service and prevent single points of failure. </p>\n    <p>Resilient engineering is not only a useful paradigm in safety critical systems; it can play an important role in software development within other fields too (Hatton and Rutkowski, 2019)</p>\n    <p>In the case of our login system example, redundancy could be incorporated by having multiple servers running the authentication service, with load balancing in place to distribute incoming requests evenly across them. If one server goes down, the load balancer can redirect traffic to the remaining servers, preventing a single point of failure and ensuring continuity of service for end-users. Equally, from a front-end software perspective, default browser fonts can operate as a ‘fallback’ for when any custom fonts cannot be loaded by the browser, thereby ensuring that the loading of font files across a network does not become a critical dependency. In short, by incorporating redundancy into node design, system designers can significantly increase the reliability and availability of their systems.</p>\n    <h3>Design for variability</h3>\n    <p>By allowing for multiple paths or options in the system's node interactions, software engineers can ensure that the system can respond effectively to changing conditions, whether these be related to user behaviour, environmental factors, or other variables.</p>\n    <p>For example, let's consider an e-commerce website that uses a login system to allow customers to access their accounts. If the website's login node is designed with only one path of interaction, such as a single database that stores user login information, the system may encounter problems if that database goes offline. However, if the login node is designed with multiple paths of interaction, such as multiple databases or a cloud-based authentication service, the system can continue to function even if one of these paths is unavailable.</p>\n    <p>Designing for variability also means considering different scenarios and planning for them in advance. For example, in the case of an unexpected surge in user traffic, the login system should be able to handle a larger number of login requests without becoming overloaded or experiencing delays. By anticipating potential changes and designing for variability, software engineers can create more resilient and adaptable systems that are better able to handle a range of situations. From a front-end perspective, designing for variability could be as simple as ensuring that a front-end application is compatible on all common web browsers.</p>\n    <h3>Implement monitoring and feedback</h3>\n    <p>Implementing monitoring and feedback mechanisms is key to ensuring that a system's node performance remains optimal. Without such mechanisms, it is difficult to detect issues in node behaviour, which can lead to degraded performance and even system failure. For example, in the case of our \"login\" system, implementing monitoring and feedback mechanisms could involve setting up alerts to notify the system administrator when login requests exceed a certain threshold or when response times exceed a set limit. Additionally, collecting and analysing log data can help identify patterns and potential issues in node performance. By continuously monitoring and analysing node behaviour, engineers can proactively respond to issues, fine-tune system configurations, and make adjustments to prevent further degradation in performance.</p>\n    <p>It is good design practice for each node to have its own monitoring capabilities, which can provide valuable data to detect and respond to issues promptly. In the case of the log-in system, it is essential to have logging on both the front-end and the authentication service, not just one. This approach helps with root cause analysis, making it easier to identify the node responsible for issues and address them quickly. </p>\n    <p>Additionally, it's important to consider that monitoring capabilities will reside in a different node in the system, rather than the node in question itself; this is because each node should have a singular purpose. </p>\n    <h3>Ensure security and privacy</h3>\n    <p>The sensitive data and information that flows through these interactions can be targeted by malicious actors, leading to data breaches and other cybersecurity incidents. To mitigate these risks, appropriate measures and safeguards must be implemented. This includes things like data encryption, access control mechanisms, and secure communication protocols.</p>\n    <p>In the context of the log-in system example, security measures could include password hashing, two-factor authentication, and role-based access control to ensure that only authorised users have access to sensitive data. Additionally, secure communication protocols like HTTPS could be implemented to protect data transmission between nodes.</p>\n    <p>Privacy is also a critical consideration in node design. In some systems, nodes may collect and process personal data about users, which must be handled with care to avoid breaches of privacy. Measures such as anonymization and pseudonymization of data can help to protect user privacy. It is important to ensure that appropriate legal and regulatory requirements are met, such as the General Data Protection Regulation (GDPR) in the European Union.</p>\n    <h3>Consider environmental factors</h3>\n    <p>Environmental factors can significantly impact the performance of a system's node. For example, the likely environment in which a software UI is to be used can impact the design and usability of the system. If the log-in system is to be used on a UI on a factory shop-floor, bright lighting in these environments, often installed to reduce risk of trips and falls, is likely to cause glare when looking at digital interfaces, making it difficult for users to read text on the screen. Therefore, appropriate colour schemes and font sizes that improve readability in such conditions need to be considered during the design process. Additionally, factors such as network latency or limited bandwidth may impact the performance of the system, and it is essential to consider these environmental factors during the design and testing phases.</p>\n    <h3>Summing Up</h3>\n    <p>The above considerations hopefully provide a reasonably clear explanation of items that require evaluation when looking at an individual ‘node’ design. The next challenge though is to think about how we incorporate these considerations into an iterative design process; it is near to impossible, and actually inadvisable, to try and consider all these factors at once, up-front. Therefore, the next section will outline a ‘practical guide’ to individual node requirements analysis.</p>\n    <h2>Requirements Analysis for a ‘single node’.</h2>\n    <h3>A simple ‘checklist’</h3>\n    <p>The following 8 points can serve as a useful heuristic for a \"checklist\" approach to ensuring that critical items have been considered during the development process. By addressing each of these points during the design phase, developers can ensure that they have considered key aspects of the node's operation and have put in place measures to mitigate potential issues. This can help to improve the reliability and security of the system as a whole, and ensure that it meets the needs of its users in a range of different environments and scenarios.</p>\n    <ol>\n       <li>Identify the purpose and function of the node.</li>\n       <li>Determine the criticality of the node and its role in the system.</li>\n       <li>Evaluate the environmental factors that may impact node performance.</li>\n       <li>Consider the potential risks and hazards associated with the node.</li>\n       <li>Determine the necessary redundancy and backup measures for the node.</li>\n       <li>Design for variability and flexibility in node interactions.</li>\n       <li>Implement monitoring and feedback mechanisms for the node.</li>\n       <li>Ensure security and privacy measures are in place for the node.</li>\n    </ol>\n    <h3>Example Requirement</h3>\n    <p>Here we have an example Requirement document for the ‘front-end’ of our login system from earlier.</p>\n    <p><strong>Context</strong></p>\n    <p>As part of the wider goal of delivering a new factory ‘shop floor’ operation system, we need to build log-in functionality that will allow our colleagues to easily and securely log in to their account. The purpose of this requirement is to provide an interface for users to log in to the system and access functionality that is secured by the authentication system..</p>\n    <p><strong>User Story</strong></p>\n    <p>As an assembly line employee,, I want to be able to login to the system easily and securely from the frontend so that I can gain access to functionality that is secured by the authentication system.</p>\n    <p><strong>Acceptance Criteria</strong></p>\n    <p><strong>A/C 1 Ability for User to Enter Login Details</strong></p>\n    <ul>\n       <li>Given a new user attempts to log in to the system from the frontend with valid login credentials</li>\n       <li>When the user enters their login credentials and clicks the 'Login' button</li>\n       <li>Then the system validates the credentials against the password validation rules</li>\n       <li>AND the system transmits the credentials securely over HTTPS</li>\n    </ul>\n    <p><strong>A/C 2 Ability for User to successfully pass through to next user journey step</strong></p>\n    <ul>\n       <li><strong>Given </strong>the user has entered their login credentials and clicked the 'Login' button.</li>\n       <li><strong>When </strong>the Authentication Service Response [outside scope] is successfully returned</li>\n       <li><strong>And </strong>the Response code details that the login credentials are valid</li>\n       <li><strong>Then </strong>the front-end system navigates the user automatically to initial journey step [outside scope]</li>\n    </ul>\n    <p><strong>A/C 3 Ability for User to know when Login credentials are invalid</strong></p>\n    <ul>\n       <li><strong>Given </strong>the user has entered their login credentials and clicked the 'Login' button.</li>\n       <li><strong>When </strong>the Authentication Service Response [outside scope] is successfully returned</li>\n       <li><strong>And </strong>the Response code details that the login credentials are invalid</li>\n       <li><strong>Then </strong>the system displays an appropriate error message</li>\n    </ul>\n    <p><strong>A/C 4 Ability for User to know when their account has been locked </strong></p>\n    <ul>\n       <li><strong>Given </strong>the user has entered their login credentials and clicked the 'Login' button.</li>\n       <li><strong>When </strong>the Authentication Service Response [outside scope] is successfully returned</li>\n       <li><strong>And </strong>the Response code details that too many login attempts have been made</li>\n       <li><strong>Then </strong>the system displays an appropriate error message</li>\n    </ul>\n    <p><strong>A/C 5 Ability for User to know when the Authentication Service is not operational</strong></p>\n    <ul>\n       <li><strong>Given </strong>the user has entered their login credentials and clicked the 'Login' button.</li>\n       <li><strong>When </strong>no Authentication Service Response [outside scope] is successfully returned</li>\n       <li><strong>Then </strong>the system displays an appropriate error message</li>\n    </ul>\n    <p><strong>A/C 6 Ability for users in ‘high light’ environments (e.g. factory shop-floor) to have clear visibility of options on login page.</strong></p>\n    <ul>\n       <li><strong>Given </strong>the user is operating the log-in system on a UI located on a factory shop-floor.</li>\n       <li><strong>When </strong>the UI is loaded on the user's device.</li>\n       <li><strong>Then </strong>the colour scheme of the UI shall include high-contrast colours that improve readability in bright or glare-prone environments.</li>\n       <li><strong>And </strong>the text labels for all UI elements shall have a font size of at least 12 points.</li>\n       <li><strong>And </strong>the background colour of the UI shall be a dark colour to minimise the contrast with the text labels.</li>\n       <li><strong>And</strong> the contrast ratio between text and background shall be at least 4.5:1 to meet the Web Content Accessibility Guidelines (WCAG) 2.1 Level AA standard.</li>\n       <li><strong>And</strong> the colour scheme shall be consistent across all UI elements, including text, buttons, and input fields.</li>\n    </ul>\n    <p><strong>A/C 8 Ability for front-end events to be logged in analytics</strong></p>\n    <ul>\n       <li><strong>Given </strong>the user is operating the log-in system on a UI located on a factory shop-floor.</li>\n       <li><strong>When </strong>the UI is loaded on the user's device</li>\n       <li><strong>And </strong>the user is actively interacting with items on screen</li>\n       <li><strong>Then </strong>these events are processed via a Data Layer that can then be used by Google Analytics.</li>\n    </ul>\n    <h3>Analysis:</h3>\n    <table>\n       <thead>\n          <tr>\n             <th>\n                <p><strong>Point</strong></p>\n             </th>\n             <th>\n                <p><strong>Covered By</strong></p>\n             </th>\n          </tr>\n          <tr>\n             <th>\n                <p>Identify the purpose and function of the node</p>\n             </th>\n             <th>\n                <p>Context and User Story sections, A/C 1: Ability for User to Enter Login Details</p>\n             </th>\n          </tr>\n          <tr>\n             <th>\n                <p>Determine the criticality of the node and its role in the system</p>\n             </th>\n             <th>\n                <p>Context and User Story sections, A/C 2: Ability for User to successfully pass through to next user journey step, A/C 3: Ability for User to know when Login credentials are invalid, A/C 4: Ability for User to know when their account has been locked, A/C 5: Ability for User to know when the Authentication Service is not operational</p>\n             </th>\n          </tr>\n          <tr>\n             <th>\n                <p>Evaluate the environmental factors that may impact node performance</p>\n             </th>\n             <th>\n                <p>A/C 6: Ability for User in ‘high light’ environments (e.g. factory shop-floor) to have clear visibility of options on login page</p>\n             </th>\n          </tr>\n          <tr>\n             <th>\n                <p>Consider the potential risks and hazards associated with the node</p>\n             </th>\n             <th>\n                <p>A/C 1: The system transmits the credentials securely over HTTPS, A/C 3: The system displays an appropriate error message if login credentials are invalid, A/C 4: The system displays an appropriate error message if too many login attempts have been made</p>\n             </th>\n          </tr>\n          <tr>\n             <th>\n                <p>Determine the necessary redundancy and backup measures for the node</p>\n             </th>\n             <th>\n                <p>A/C 5: Ability for User to know when the Authentication Service is not operational</p>\n             </th>\n          </tr>\n          <tr>\n             <th>\n                <p>Design for variability and flexibility in node interactions</p>\n             </th>\n             <th>\n                <p>A/C 2: The front-end system navigates the user automatically to the initial journey step, which may vary depending on the user</p>\n             </th>\n          </tr>\n          <tr>\n             <th>\n                <p>Implement monitoring and feedback mechanisms for the node</p>\n             </th>\n             <th>\n                <p>A/C 8: Ability for front-end events to be logged in analytics</p>\n             </th>\n          </tr>\n          <tr>\n             <th>\n                <p>Ensure security and privacy measures are in place for the node</p>\n             </th>\n             <th>\n                <p>A/C 1: The system validates the credentials against the password validation rules and transmits the credentials securely over HTTPS, A/C 3: The system displays an appropriate error message if login credentials are invalid, A/C 4: The system displays an appropriate error message if too many login attempts have been made</p>\n             </th>\n          </tr>\n       </thead>\n    </table>\n    <p>The above table provides a breakdown of how the example requirement meets each of the individual node requirements checklist. By identifying the purpose and function of the node, developers were able to define the user story and context, as well as the first acceptance criteria of the requirement - the ability for the user to enter login details. Determining the criticality of the node and its role in the system is reflected in the acceptance criteria that cover the user's ability to pass through to the next step, know when their credentials are invalid, and be alerted when the authentication service is not operational. Other requirements, such as evaluating environmental factors, considering risks and hazards, designing for flexibility, and implementing monitoring and feedback mechanisms, are also addressed through various acceptance criteria. Overall, this table demonstrates how the example requirement has been thoroughly evaluated and designed to meet each of the individual node requirements.</p>\n    <h2>‘Complex Systems’ toolkits</h2>\n    <p>In the last few sections, we have talked about  individual ‘node design’ and arguably this is the most important area to focus on when designing complex systems. In this section we’ll cover some simple toolkits that can be used to evaluate whether or not an ‘individual node’’ requirements are sufficient in order to reduce the risk of undesirable emergent behaviour.</p>\n    <h3>‘Checklist’ Questions for ‘Front-End’ Software Development</h3>\n    <p>Here are 20 simple questions within the context of front-end software development that can help answer the following points:</p>\n    <p><strong>Identify the purpose and function of the node. (Purpose and Function)</strong></p>\n    <ol>\n       <li>What is the main objective of this node?</li>\n       <li>What functionality does this node provide to the user?</li>\n       <li>How does this node fit into the overall system architecture?</li>\n    </ol>\n    <p><strong>Determine the criticality of the node and its role in the system. (Criticality and Role)</strong></p>\n    <ol>\n       <li>4. What would happen if this node fails or malfunctions?</li>\n       <li>How important is this node in achieving the overall goals of the system?</li>\n       <li>What are the consequences of a user not being able to interact with this node?</li>\n    </ol>\n    <p><strong>Evaluate the environmental factors that may impact node performance. (Environmental Factors)</strong></p>\n    <ol>\n       <li>Will this node be used in a variety of environments, such as indoors or outdoors?</li>\n       <li>What are the lighting conditions in which this node will be used?</li>\n       <li>Will there be any environmental factors that may cause interference with this node's performance?</li>\n    </ol>\n    <p><strong>Consider the potential risks and hazards associated with the node. (Risks and Hazards)</strong></p>\n    <ol>\n       <li>What are the security risks associated with this node?</li>\n       <li>Are there any potential safety hazards that could arise from this node's operation?</li>\n       <li>What could be the potential legal consequences of this node's malfunction?</li>\n    </ol>\n    <p><strong>Determine the necessary redundancy and backup measures for the node. (Redundancy and Backup)</strong></p>\n    <ol>\n       <li> How will the system ensure that this node is always available for use?</li>\n       <li>Are there any backup measures in place to ensure that this node can still function in the event of a failure?</li>\n       <li>How will the system ensure data is preserved in the event of node failure?</li>\n    </ol>\n    <p><strong>Design for variability and flexibility in node interactions. (Variability and Flexibility)</strong></p>\n    <ol>\n       <li>How will the design of this node allow for interaction with users of varying abilities?</li>\n       <li>Will this node be accessible to users with different languages or cultures?</li>\n       <li>How will the design of this node allow for flexibility in its use in different situations?</li>\n    </ol>\n    <p><strong>Implement monitoring and feedback mechanisms for the node. (Monitoring and Feedback)</strong></p>\n    <ol>\n       <li>How will the system monitor the performance of this node?</li>\n       <li>What feedback mechanisms will be put in place to inform users if there is an issue with this node?</li>\n    </ol>\n    <h3>‘Checklist’ Questions for ‘Back-End’ Software Development</h3>\n    <p><strong>Identify the purpose and function of the system:</strong></p>\n    <ol>\n       <li>What is the primary objective of the node?</li>\n       <li>What are the key features that the node provides to the user?</li>\n       <li>What are the main functions of the node?</li>\n       <li>How does the node interact with other parts of the system?</li>\n    </ol>\n    <p><strong>Determine the criticality of the system and its role in the overall system:</strong></p>\n    <ol>\n       <li>What are the consequences of the node failing?</li>\n       <li>What is the impact on the overall system if the node is down?</li>\n       <li>How does the node affect the performance of the overall system?</li>\n       <li>What is the importance of the node to the overall system?</li>\n    </ol>\n    <p><strong>Evaluate the environmental factors that may impact system performance:</strong></p>\n    <ol>\n       <li>How does the node perform in high traffic scenarios?</li>\n       <li>What is the expected load on the node?</li>\n       <li>How does the node perform under heavy data processing loads?</li>\n       <li>What are the security and compliance requirements of the node?</li>\n    </ol>\n    <p><strong>Consider the potential risks and hazards associated with the system:</strong></p>\n    <ol>\n       <li>What are the potential security threats to the node?</li>\n       <li>How does the node protect against data breaches?</li>\n       <li>What are the potential risks associated with data storage?</li>\n       <li>How does the node protect against unauthorised access?</li>\n    </ol>\n    <p><strong>Determine the necessary redundancy and backup measures for the system:</strong></p>\n    <ol>\n       <li>What backup and recovery measures are in place for the node?</li>\n       <li>What are the failover mechanisms in case of a node failure?</li>\n       <li>How are system logs and data backups managed?</li>\n       <li>How does the node ensure data integrity and accuracy?</li>\n    </ol>\n    <h2>Wrapping Up</h2>\n    <h3>Summary</h3>\n    <p>Throughout this article, we have explored the importance of understanding node interactivity, emergent behaviour, and designing for complex systems. We have seen how these concepts can have practical implications and how they relate to issues such as exponential growth and chaos. We have also discussed various approaches to complex system design, including identifying system components, analysing system dynamics, and designing for resilience. Additionally, we have covered the importance of considering factors such as human nodes, redundancy, variability, and environmental factors when designing for complex systems. </p>\n    <p>This article has emphasised the importance of designing complex systems with a holistic approach that considers the interactivity between nodes and potential emergent behaviour. At the same time, it is also important to consider individual node design in detail, incorporating redundancy, variability, monitoring, feedback, security, and environmental factors. While each node is an essential component of the system, it is their interconnectivity that enables the system to function as a whole. Therefore, a balance needs to be struck between the two perspectives to ensure that the system operates effectively, efficiently, and securely. Ultimately, by taking a holistic approach to designing complex systems while also paying attention to individual node design, we can create systems that are flexible, resilient, and adaptive to change.</p>\n    <p>Probably one of the most important factors when designing complex systems is ensuring that the human elements of a complex system are well understood. This is  because it is humans that will ultimately interact with and operate the system. It is important to consider their needs, motivations, and limitations when designing and implementing the system. Failure to take these factors into account can lead to poor adoption, low engagement, or even failure of the system. For example, when designing a software application, it is crucial to consider the user experience, accessibility, and usability of the application. This includes understanding the needs and limitations of different user groups, such as those with disabilities, low digital literacy, or cultural differences. Additionally, it is important to consider the motivations of the users, such as what drives them to use the application and what features they find valuable. However, one thing that is often forgotten in system design is that ‘users’ does not only mean ‘end-users’; when we talk about ‘human nodes’ we are referring to any individual who plays a role in the system, including developers, administrators, and other stakeholders. Understanding the needs, motivations, and limitations of these human nodes is crucial to designing effective and usable systems. </p>\n    <p>Putting aside the complexity of any discussion of systems thinking and the theoretical underpinning of complex systems, the key point this article has hoped to raise is this: no matter the complexity of the system in question, if individual nodes are designed with the clear knowledge that complex systems have a tendency to be unpredictable (i.e. give rise to unexpected emergent behaviour), then risks to the overall system can be mitigated. Put more simply: creating individually well designed ‘nodes’ is half the battle in designing robust complex systems. However, good design is one thing but  having a mental model (such as the ‘node interactivity model’ as outlined above) to help conceptualise the designer’s place in the overall ‘network’ is just as important. Afterall, designers, through the process of design, become part of the system they’re designing themselves.   </p>\n    <h3>Further areas of study</h3>\n    <p>The principles outlined in this article have far-reaching implications across a wide range of fields and domains. In software engineering, for example, the design of complex systems is a fundamental part of the development process. By understanding the interactions between nodes and designing for emergent behaviour, software developers can create more resilient and adaptable systems. In network science, the study of complex systems is essential for understanding the behaviour of social, economic, technical and biological networks  (Barabási and Oltvai, 2004) . By considering the individual nodes and their interactions, researchers can gain insights into the emergence of global phenomena such as viral outbreaks, financial crises (Capelli, 2022), and social movements. By understanding the motivations and limitations of individual nodes, researchers can develop strategies for improving overall systems, whether these systems are biological, technological or social .</p>\n    <p>As complex systems become more prevalent in our daily lives, there are many potential challenges and areas for future research and development. One area of interest is the role of artificial intelligence (AI) in complex systems. As AI becomes more advanced, it may be possible to incorporate machine learning algorithms into complex systems to help manage emergent behaviour and improve predictability. However, this raises questions about the potential unintended consequences of AI and how to ensure that it aligns with ethical and social considerations (Bommasani et al., 2021). As complex systems continue to evolve and intersect with emerging technologies, it will be important for researchers and practitioners to address these challenges and explore new approaches to designing, managing, and analysing these systems (Steinhardt, J., 2021). </p>\n<h3>References</h3><ul><li>Almazroi, A.A., 2023. An Empirical Investigation of Factors Influencing the Adoption of Internet of Things Services by End-Users. Arabian Journal for Science and Engineering, 48(2), pp.1641-1659.</li><li>Alon, U., 2003. Biological networks: the tinkerer as an engineer. Science, 301(5641), pp.1866-1867.</li><li>Assaad, R., Dagli, C. and El-Adaway, I.H., 2020. A system-of-systems model to simulate the complex emergent behaviour of vehicle traffic on an urban transportation infrastructure network. Procedia Computer Science, 168, pp.139-146.</li><li>Barabási, A. and Oltvai, Z., 2004. Network biology: understanding the cell’s functional organisation. Nature Reviews Genetics, 5(2), pp.101-113.</li><li>Barabási, A.-L. (2002). Linked: The New Science of Networks. Perseus Publishing.</li><li>Betley, E., Sterling, E.J., Akabas, S., Paxton, A. and Frost, L., 2021. Introduction to systems and systems thinking. Lessons in Conservation, 11, pp.9-25.</li><li>Boccaletti, S., Latora, V., Moreno, Y., Chavez, M., &amp; Hwang, D.-U. (2006). Complex networks: Structure and dynamics. Physics Reports, 424(4-5), 175-308. https://doi.org/10.1016/j.physrep.2005.10.009</li><li>Bommasani, R., Hudson, D.A., Adeli, E., Altman, R., Arora, S., von Arx, S., Bernstein, M.S., Bohg, J., Bosselut, A., Brunskill, E. and Brynjolfsson, E., 2021. On the opportunities and risks of foundation models. arXiv preprint arXiv:2108.07258.</li><li>Brtis, J.S. and McEvilley, M.A., 2019. Systems engineering for resilience. MITRE Technical Document, 190495.</li><li>Capelli, I., 2022. The Complexity Theory and Financial Systems Regulation. In Complexity and Emergence: Lake Como School of Advanced Studies, Italy, July 22–27, 2018 (pp. 49-62). Cham: Springer International Publishing.</li><li>Delgado-Maciel, J., Cortés-Robles, G., Sánchez-Ramírez, C., García-Alcaraz, J. and Méndez-Contreras, J.M., 2020. The evaluation of conceptual design through dynamic simulation: A proposal based on TRIZ and system dynamics. Computers &amp; Industrial Engineering, 149, p.106785.</li><li>Fisher, D.N. and Pruitt, J.N., 2020. Insights from the study of complex systems for the ecology and evolution of animal populations. Current Zoology, 66(1), pp.1-14.</li><li>Frølich, E.F., Thygesen, U.H. and Andersen, K.H., 2022. Scaling from optimal behaviour to population dynamics and ecosystem function. Ecological Complexity, p.101027.</li><li>Haartsen, T. and Venhorst, V., 2014. The self-reinforcing effects of population decline: An analysis of differences in moving behaviour between rural neighbourhoods with declining and stable populations. Journal of Rural Studies, 36, pp.285-299.</li><li>Hatton, L. and Rutkowski, A., 2019. \" Lessons must be learned\"-but are they?. IEEE software, 36(4), pp.91-95.</li><li>Herranz Jr, J., 2009. The A, B, C’s of Self-reinforcing Processes in Network Resiliency: Adapting, Bouncing Back, and Coping.</li><li>Hevey, D., 2018. Network analysis: a brief overview and tutorial. Health Psychology and Behavioral Medicine, 6(1), pp.301-328.</li><li>Inclan, E., 2021. A method for system of systems definition and modelling using patterns of collective behaviour (Doctoral dissertation, Georgia Institute of Technology</li><li>Ivanova, I., Smorodinskaya, N. and Leydesdorff, L., 2020. On measuring complexity in a post-industrial economy: The ecosystem’s approach. Quality &amp; Quantity, 54, pp.197-212.</li><li>Kortum, F., Klünder, J. and Schneider, K., 2017. Characterizing relationships for system dynamics models supported by exploratory data analysis. In 29th International Conference on Software Engineering and Knowledge Engineering. KSI Research Inc (Vol. 15, pp. 39-43).</li><li>Liu, Y., Wang, J., He, H., Huang, G. and Shi, W., 2021. Identifying important nodes affecting network security in complex networks. International Journal of Distributed Sensor Networks, [online] 17(2). </li><li>Macktoobian, M., 2022. Self-organising nest migration dynamics synthesis for ant colony systems. Natural Computing, pp.1-10.</li><li>Manson, S.M., 2001. Simplifying complexity: a review of complexity theory. Geoforum, 32(3), pp.405-414.</li><li>Neumann, W.P., Winkelhaus, S., Grosse, E.H. and Glock, C.H., 2021. Industry 4.0 and the human factor–A systems framework and analysis methodology for successful development. International journal of production economics, 233, p.107992.</li><li>Pinto, V.H.S.C., de Souza, A.L.O.T., de Oliveira, Y.M.B. and Ribeiro, D.M., 2021. Cognitive-Driven Development: Preliminary Results on Software Refactorings. In ENASE (pp. 92-102).</li><li>Seabrook, I., Barucca, P. and Caccioli, F., 2022. Structural importance and evolution: An application to financial transaction networks. Physica A: Statistical Mechanics and its Applications, 607, pp.128203.</li><li>Song, Y., Fang, X., Liu, B., Li, C., Li, Y. and Yang, S.X., 2020. A novel foraging algorithm for swarm robotics based on virtual pheromones and neural networks. Applied Soft Computing, 90, p.106156.</li><li>Steinhardt, J., 2021. On The Risks of Emergent Behavior in Foundation Models. [online] Stanford Center for Research on Foundation Models. </li><li>Venkatesh, V., Thong, J.Y., Chan, F.K., Hoehle, H. and Spohrer, K., 2020. How agile software development methods reduce work exhaustion: Insights on role perceptions and organizational skills. Information Systems Journal, 30(4), pp.733-761.</li><li>Wingo, R.S., 2015. Transforming Complexity into Order: A Grounded Theory of an Agile Methodology Applied to Complex Problem Domains (Doctoral dissertation, The University of Alabama at Birmingham).</li><li>Zaheri, M., 2022, October. Towards consistency management in low-code platforms. In Proceedings of the 25th International Conference on Model Driven Engineering Languages and Systems: Companion Proceedings (pp. 176-181).</li><li>Zheng, Z., 2020. An Introduction to Emergence Dynamics in Complex Systems. In: Frontiers and Progress of Current Soft Matter Research. Springer Singapore, pp.101-126. [Original source: https://studycrumb.com/alphabetizer]</li></ul>\n    ","displayShareLinks":true};